<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Atlas Maker (v3) â€“ Aspect Ratios + CSV Editor</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{ --bg:#0f172a; --panel:#0b1226; --muted:#94a3b8; --text:#e5e7eb; --accent:#22d3ee; --border:rgba(255,255,255,.14) }
  *{ box-sizing:border-box }
  body{ margin:0; font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial; background:linear-gradient(180deg,#0b1022,#0b142e 35%,#0a1736); color:var(--text) }
  header{ padding:24px 16px; text-align:center; border-bottom:1px solid rgba(255,255,255,.06) }
  header h1{ margin:0; font-size:clamp(20px,3vw,28px) }
  header p{ margin:.5rem auto 0; color:#b6c2d1; max-width:1000px }
  main{ max-width:1300px; margin:24px auto 40px; padding:0 16px }
  .grid{ display:grid; gap:16px; grid-template-columns:1fr }
  @media (min-width: 1100px){ .grid{ grid-template-columns: 520px 1fr } }
  .card{ background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)); border:1px solid var(--border); border-radius:16px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.35) }
  .card h2{ margin:0 0 12px; font-size:18px }
  label{ display:block; margin:.5rem 0 .35rem; color:#cbd5e1; font-size:14px }
  input[type="text"], input[type="number"], select, textarea{ width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border); background:#0b1226; color:var(--text); outline:none }
  textarea{ min-height:180px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; resize:vertical }
  .row{ display:flex; gap:10px; align-items:center }
  .row > *{ flex:1 }
  .hint{ color:#9fb0c6; font-size:12px; margin-top:6px }
  .drop{ border:2px dashed rgba(255,255,255,.18); border-radius:12px; padding:16px; text-align:center; background:rgba(255,255,255,.02) }
  .drop.drag{ background:rgba(34,211,238,.06); border-color:var(--accent) }
  .btn{ display:inline-flex; align-items:center; gap:8px; background:linear-gradient(180deg, #22d3ee, #06b6d4); color:#06202b; font-weight:700; border:none; border-radius:11px; padding:10px 14px; cursor:pointer; box-shadow:0 6px 16px rgba(5,150,205,.35) }
  .btn.secondary{ background:transparent; color:#d1e3f3; border:1px solid rgba(255,255,255,.15); box-shadow:none }
  .btn:disabled{ opacity:.5; cursor:not-allowed }
  .toolbar{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
  canvas{ width:100%; height:auto; border-radius:14px; background:#fff; display:block }
  .tag{ padding:2px 8px; border:1px solid rgba(255,255,255,.2); border-radius:999px; font-size:12px; color:#bfe9f5 }
  .warn{ color:#fcd34d; font-size:13px }
  .ok{ color:#86efac; font-size:13px }
  .kv{ display:grid; grid-template-columns: 160px 1fr; gap:8px; font-size:13px; color:#c7d5e7 }
  code.inline{ background:#0b1226; border:1px solid rgba(255,255,255,.12); padding:1px 6px; border-radius:6px }
  .switch{ display:flex; align-items:center; gap:8px; font-size:13px }
</style>
</head>
<body>
<header>
  <h1>Atlas Maker (v3)</h1>
  <p>Paste CSV or upload a file. Supports <strong>Aspect Ratio</strong> per row (e.g. <code class="inline">1:1</code>, <code class="inline">2:1</code>, <code class="inline">1:2</code>). Toggle the <strong>Power-of-Two</strong> requirement on/off. Elements are maximized to fit the atlas while respecting aspect and other constraints.</p>
</header>
<main class="grid">
  <section class="card">
    <h2>1) CSV Input</h2>
    <label for="csvText">Paste CSV here</label>
    <textarea id="csvText" placeholder="Texture Name,size,Aspect Ratio\nGrass,s,1:1\nBrick,l,2:1\nBanner,m,1:2"></textarea>
    <div class="hint">Headers must be present: <code class="inline">Texture Name,size,Aspect Ratio</code>. Aspect Ratio defaults to <code class="inline">1:1</code> if omitted.</div>

    <div class="drop" id="drop" style="margin-top:10px">
      <div><strong>Or drag & drop</strong> a .csv file here</div>
      <div style="margin-top:8px"><input type="file" id="file" accept=".csv" /></div>
    </div>

    <h2 style="margin-top:18px">2) Atlas Settings</h2>
    <label for="atlasSize">Atlas size</label>
    <div class="row">
      <input id="atlasSize" type="text" placeholder="e.g. 4096 or 4096x2048" />
      <input id="padding" type="number" min="0" value="4" title="Padding (px)" />
    </div>
    <div class="hint">Enter a single square size (e.g. <em>2048</em>) or <em>WÃ—H</em> (e.g. <em>4096x2048</em>).</div>

    <details style="margin-top:12px">
      <summary style="cursor:pointer;color:#bfe9f5">Advanced</summary>
      <div class="row" style="margin-top:8px">
        <label>S weight</label><input id="wS" type="number" min="0.1" step="0.1" value="1">
      </div>
      <div class="row" style="margin-top:8px">
        <label>M weight</label><input id="wM" type="number" min="0.1" step="0.1" value="2">
      </div>
      <div class="row" style="margin-top:8px">
        <label>L weight</label><input id="wL" type="number" min="0.1" step="0.1" value="4">
      </div>
      <div class="row" style="margin-top:8px">
        <label>Power-of-Two</label>
        <select id="potMode">
          <option value="off" selected>Off (any integer size)</option>
          <option value="nearest">Nearest PoT (per side)</option>
          <option value="down">PoT (floor per side)</option>
        </select>
      </div>
      <div class="switch" style="margin-top:8px">
        <input id="autoUpdate" type="checkbox" checked /> <label for="autoUpdate">Auto-update on changes</label>
      </div>
      <div class="hint">When PoT is on and a ratio isn't a power-of-two fraction (e.g. <code class="inline">3:2</code>), the tool keeps the exact aspect but may not be able to make <em>both</em> sides PoT. A warning will be shown.</div>
    </details>

    <div style="margin-top:16px" class="toolbar">
      <button id="calc" class="btn">ðŸ§® Calculate & Render</button>
      <button id="save" class="btn secondary" disabled>ðŸ’¾ Save PNG</button>
      <button id="copy" class="btn secondary" disabled>ðŸ“‹ Copy PNG</button>
      <span id="status" class="tag">Paste or upload CSV to begin</span>
    </div>

    <div style="margin-top:12px" class="kv">
      <div>Parsed rows:</div><div id="rowCount">0</div>
      <div>Packing:</div><div id="fitStatus">â€“</div>
      <div>Atlas:</div><div id="atlasOut">â€“</div>
    </div>

    <details style="margin-top:12px">
      <summary style="cursor:pointer;color:#bfe9f5">Sample CSV</summary>
      <pre style="margin-top:8px;background:#0b1226;border:1px solid rgba(255,255,255,.12);padding:10px;border-radius:10px;overflow:auto"><code>Texture Name,size,Aspect Ratio
Grass,s,1:1
Dirt,m,2:1
Rock,l,1:1
Banner,m,1:2
Metal,m,4:1
Fabric,s,1:1
Brick,l,2:1
Leaves,s,1:1
Tile,m,1:1</code></pre>
    </details>
  </section>

  <section class="card">
    <h2>3) Atlas Preview</h2>
    <canvas id="canvas" width="2048" height="2048" aria-label="Atlas canvas"></canvas>
    <div id="warnings" class="hint" style="margin-top:6px"></div>
  </section>
</main>

<script>
// ===================== Helpers & Parsing =====================
function parseAtlasSize(val){
  const s = (val||'').toLowerCase().replace(/\s+/g,'').replace(/Ã—/g,'x');
  if(!s) return null; if(/^\d+$/.test(s)) return {w:+s, h:+s};
  const m = s.match(/^(\d+)[x,](\d+)$/); if(m) return {w:+m[1], h:+m[2]}; return null;
}
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b] = [b, a%b]; } return a; }
function isPow2(n){ return n && (n & (n-1)) === 0; }
function nextPow2(n){ n = Math.max(1, n|0); n--; n|=n>>1; n|=n>>2; n|=n>>4; n|=n>>8; n|=n>>16; return (n+1); }
function prevPow2(n){ if(n<=1) return 1; return 1 << (31-Math.clz32(n)); }
function roundPow2(n, mode){ if(n<=1) return 1; if(isPow2(n)) return n; const down = prevPow2(n); const up = nextPow2(n); if(mode==='down') return down; return (up-n) < (n-down) ? up : down; }

function parseCSV(text){
  const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
  if(!lines.length) return [];
  const header = lines[0].split(',').map(h=>h.trim().toLowerCase());
  const nameIdx = header.findIndex(h=> h.startsWith('texture'));
  const sizeIdx = header.findIndex(h=> h === 'size' || h.endsWith('size'));
  const arIdx = header.findIndex(h=> h.includes('aspect'));
  if(nameIdx === -1 || sizeIdx === -1) throw new Error("CSV must include 'Texture Name' and 'size'. Optional 'Aspect Ratio'.");
  const out = [];
  for(let i=1;i<lines.length;i++){
    const cols = lines[i].split(',');
    if(cols.length < 2) continue;
    const name = (cols[nameIdx]||'').trim();
    const sz = (cols[sizeIdx]||'').trim().toLowerCase();
    if(!name || !['s','m','l'].includes(sz)) continue;
    let ar = (arIdx>=0 ? (cols[arIdx]||'').trim() : '') || '1:1';
    let m = ar.match(/^(\d+)\s*[:x]\s*(\d+)$/i); // allow 2:1 or 2x1
    let aw=1, ah=1;
    if(m){ aw = Math.max(1, parseInt(m[1])); ah = Math.max(1, parseInt(m[2])); }
    const d = gcd(aw, ah); aw/=d; ah/=d; // reduce
    out.push({name, size:sz, arW:aw, arH:ah});
  }
  // de-dupe names for clarity
  const seen = new Map();
  for(const it of out){ const base = it.name; const c = seen.get(base)||0; if(c>0) it.name = `${base} (${c+1})`; seen.set(base, c+1); }
  return out;
}

// ===================== Rectangle Sizing with Aspect =====================
// We maximize a scale factor u via binary search. Base area for item i is (u^2 * weight[i]).
// Given aspect p:q, non-PoT size is w=round(sqrt(area * p/q)), h=round(w * q/p).
// If PoT is ON, we round each side to PoT while keeping aspect EXACT by recomputing from a shared scalar k when possible.

function sizesForItem(area, p, q, potMode, warnings){
  // raw ideal sizes (float)
  const wIdeal = Math.sqrt(area * p / q);
  const hIdeal = wIdeal * q / p;
  if(potMode === 'off'){
    return { w: Math.max(1, Math.round(wIdeal)), h: Math.max(1, Math.round(hIdeal)), exactAspect:true, pot:false };
  }
  // Check if we can have both sides PoT while keeping exact aspect: require p and q be powers of two
  const pPow = isPow2(p), qPow = isPow2(q);
  if(pPow && qPow){
    // Choose k so that k*p ~ wIdeal and k*q ~ hIdeal, with k power-of-two-ish implied by roundPow2 on either side proportionally
    // Compute kIdeal via width, then choose PoT rounding on k
    const kIdeal = wIdeal / p; // == hIdeal / q
    const k = roundPow2(Math.max(1, Math.round(kIdeal)), potMode);
    return { w: k * p, h: k * q, exactAspect:true, pot:true };
  }
  // Otherwise: keep exact aspect using a shared integer scalar k, but we cannot make both sides PoT
  // We'll round the scalar to an integer and warn once.
  const kIdeal = wIdeal / p; // == hIdeal / q
  const k = Math.max(1, Math.round(kIdeal));
  if(warnings) warnings.potIncompat = true;
  return { w: k * p, h: k * q, exactAspect:true, pot:false };
}

// ===================== Binary-tree packer =====================
function createNode(x,y,w,h){ return {x,y,w,h, used:false, right:null, down:null}; }
function findNode(node, w, h){ if(!node) return null; if(node.used) return findNode(node.right, w, h) || findNode(node.down, w, h); if(w<=node.w && h<=node.h) return node; return null; }
function splitNode(node, w, h){ node.used = true; node.down = createNode(node.x, node.y + h, node.w, node.h - h); node.right = createNode(node.x + w, node.y, node.w - w, h); return node; }
function tryPack(rects, W, H, pad){ const root = createNode(0,0,W,H); for(const r of rects){ const node = findNode(root, r.w + pad*2, r.h + pad*2); if(!node) return false; const placed = splitNode(node, r.w + pad*2, r.h + pad*2); r.x = placed.x + pad; r.y = placed.y + pad; } return true; }

// ===================== Builder with Binary Search Maximize =====================
function buildRects(items, W, H, pad, weights, potMode){
  const wts = items.map(t => (weights[t.size]||1));
  const idx = [...items.keys()].sort((a,b)=> wts[b]-wts[a]);
  const warnings = { potIncompat:false };

  function canFit(u){
    const rects = idx.map(i => {
      const area = Math.max(1, (u*u) * wts[i]);
      const s = sizesForItem(area, items[i].arW, items[i].arH, potMode, warnings);
      return { i, name:items[i].name, size:items[i].size, w:s.w, h:s.h, ar:`${items[i].arW}:${items[i].arH}` };
    }).sort((a,b)=> (b.h - a.h) || (b.w - a.w));
    const ok = tryPack(rects, W, H, pad);
    return { ok, rects };
  }

  let lo = 1, hi = Math.min(W,H);
  let best = null;
  // Exponential upper bound
  while(true){ const {ok} = canFit(hi); if(ok){ lo = hi; hi *= 2; if(hi > 1<<20) break; } else break; }
  // Binary search
  for(let it=0; it<40; it++){
    const mid = (lo + hi) / 2; const res = canFit(mid); if(res.ok){ best = res; lo = mid; } else { hi = mid; }
  }
  if(!best) best = canFit(1);
  best.warnings = warnings;
  return best;
}

// ===================== Drawing =====================
function measureText(ctx, text, maxWidth, fontSize){ ctx.save(); ctx.font = `${fontSize}px ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial`; const lines=[]; const words=text.split(/\s+/); let cur=''; for(const w of words){ const tryLine = cur?cur+' '+w:w; if(ctx.measureText(tryLine).width<=maxWidth) cur=tryLine; else{ if(cur) lines.push(cur); cur=w; } } if(cur) lines.push(cur); ctx.restore(); return lines; }
function drawAtlas(canvas, W, H, rects, pad){
  canvas.width=W; canvas.height=H; const ctx=canvas.getContext('2d'); ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,W,H);
  ctx.globalAlpha=0.05; const grid=64; for(let gy=0; gy<H; gy+=grid){ for(let gx=0; gx<W; gx+=grid){ ctx.fillStyle=((gx/grid+gy/grid)%2)?'#000':'#666'; ctx.fillRect(gx,gy,grid,grid);} } ctx.globalAlpha=1;
  ctx.lineWidth=Math.max(1, Math.round(Math.max(W,H)/1024));
  for(const r of rects){ ctx.fillStyle='#f3f4f6'; ctx.fillRect(r.x,r.y,r.w,r.h); ctx.strokeStyle='#374151'; ctx.strokeRect(r.x+.5,r.y+.5,r.w-1,r.h-1);
    const inset=Math.max(6, Math.floor(Math.min(r.w,r.h)*0.06)); const labelW=r.w-inset*2; const labelH=r.h-inset*2; ctx.save(); ctx.beginPath(); ctx.rect(r.x+inset, r.y+inset, labelW, labelH); ctx.clip();
    const title=r.name; const dims=`${r.w}Ã—${r.h}px`; const ar=r.ar; const base=Math.max(10, Math.floor(Math.min(r.w,r.h)*0.12)); const titleLines=measureText(ctx, title, labelW, base); const dy=Math.min(labelH, (titleLines.length*(base+2)+base+4));
    ctx.fillStyle='#111827'; ctx.font=`bold ${base}px ui-sans-serif, system-ui, Segoe UI`; let ty=r.y+inset+base+1; for(const line of titleLines){ ctx.fillText(line, r.x+inset+2, ty); ty+=base+2; if(ty>r.y+inset+labelH-base) break; }
    ctx.fillStyle='#374151'; ctx.font=`bold ${Math.max(10, Math.floor(base*0.78))}px ui-sans-serif, system-ui`; ctx.fillText(`${dims}  â€¢  AR ${ar}`, r.x+inset+2, r.y+inset+dy);
    ctx.restore(); }
  ctx.strokeStyle='#0f172a'; ctx.lineWidth=2; ctx.strokeRect(1,1,W-2,H-2);
}

// ===================== UI =====================
const el = id=>document.getElementById(id);
const csvText = el('csvText');
const drop = el('drop');
const file = el('file');
const calc = el('calc');
const saveBtn = el('save');
const copyBtn = el('copy');
const status = el('status');
const rowCount = el('rowCount');
const fitStatus = el('fitStatus');
const atlasOut = el('atlasOut');
const warningsEl = el('warnings');
const canvas = el('canvas');

let textures = [];

function setStatus(txt){ status.textContent = txt; }
function setButtons(can){ saveBtn.disabled = !can; copyBtn.disabled = !can || !('clipboard' in navigator); }

function parseInputs(){
  const pad = Math.max(0, +el('padding').value || 0);
  const weights = { s: Math.max(0.01, +el('wS').value || 1), m: Math.max(0.01, +el('wM').value || 2), l: Math.max(0.01, +el('wL').value || 4) };
  const potMode = el('potMode').value; // off | nearest | down
  const sizeParsed = parseAtlasSize(el('atlasSize').value.trim());
  const W = sizeParsed ? sizeParsed.w : canvas.width; const H = sizeParsed ? sizeParsed.h : canvas.height;
  return { pad, weights, potMode, W, H };
}

function recalc(){
  if(!textures.length){ setStatus('Paste/upload CSV first'); return; }
  const {pad, weights, potMode, W, H} = parseInputs();
  const result = buildRects(textures, W, H, pad, weights, potMode);
  drawAtlas(canvas, W, H, result.rects, pad);
  atlasOut.textContent = `${W}Ã—${H}`;
  fitStatus.innerHTML = result.ok ? '<span class="ok">Maximized & packed</span>' : '<span class="warn">Packed at minimum scale</span>';
  setButtons(true);
  setStatus(`Packed ${textures.length} textures`);
  warningsEl.textContent = result.warnings.potIncompat && potMode !== 'off' ? 'Warning: Some aspect ratios are not pure powers-of-two (e.g., 3:2). Those cells keep exact aspect but cannot make both sides power-of-two.' : '';
}

function ingestCSV(text){
  try{ const rows = parseCSV(text); textures = rows; rowCount.textContent = rows.length; setStatus(`Loaded ${rows.length} textures`); if(el('autoUpdate').checked) recalc(); }
  catch(e){ textures = []; rowCount.textContent = '0'; setStatus('Error: ' + e.message); }
}

// Wire inputs
calc.addEventListener('click', recalc);
['atlasSize','padding','wS','wM','wL','potMode','autoUpdate'].forEach(id=> el(id).addEventListener('input', ()=>{ if(el('autoUpdate').checked) recalc(); }));
csvText.addEventListener('input', ()=>{ if(el('autoUpdate').checked){ ingestCSV(csvText.value); } });

// Drag & drop / file
['dragover','dragenter'].forEach(ev=>drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.add('drag'); }));
['dragleave','drop'].forEach(ev=>drop.addEventListener(ev, ()=> drop.classList.remove('drag')));
drop.addEventListener('drop', e=>{ e.preventDefault(); const f = e.dataTransfer.files?.[0]; if(!f) return; if(!/\.csv$/i.test(f.name)){ setStatus('Please drop a .csv file'); return; } f.text().then(t=>{ csvText.value = t; ingestCSV(t); }); });
file.addEventListener('change', e=>{ const f = e.target.files?.[0]; if(!f) return; f.text().then(t=>{ csvText.value = t; ingestCSV(t); }); });

// Save & Copy
saveBtn.addEventListener('click', ()=>{ const sizeParsed = parseAtlasSize(el('atlasSize').value.trim()); const W = sizeParsed ? sizeParsed.w : canvas.width; const H = sizeParsed ? sizeParsed.h : canvas.height; const fname = `atlas_${W}x${H}.png`; canvas.toBlob(blob=>{ if(!blob) return; const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = fname; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },100); }, 'image/png'); });
copyBtn.addEventListener('click', async ()=>{ try{ const blob = await new Promise(res => canvas.toBlob(res, 'image/png')); if(!blob) throw new Error('No blob'); await navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]); setStatus('PNG copied to clipboard'); } catch(err){ setStatus('Clipboard copy not supported in this context'); } });

// Defaults
el('atlasSize').value = '2048';
setStatus('Paste or upload CSV to begin');
</script>
</body>
</html>
